<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>evpv.mobilitysim &#8212; EV-PV  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=61cd365c" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=12dfc556" />
    <script src="../../_static/documentation_options.js?v=5929fcd5"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for evpv.mobilitysim</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>

<span class="sd">&quot;&quot;&quot; </span>
<span class="sd">MobilitySim </span>

<span class="sd">A class to simulate the daily travel demand for different road-based transport modes (car, motorbike) for various</span>
<span class="sd">mobility chains specified by the user (home-work-home, home-school-home, etc)</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">rasterio</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">shape</span><span class="p">,</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Point</span><span class="p">,</span> <span class="n">Polygon</span><span class="p">,</span> <span class="n">box</span><span class="p">,</span> <span class="n">MultiPoint</span>
<span class="kn">from</span> <span class="nn">shapely.ops</span> <span class="kn">import</span> <span class="n">transform</span><span class="p">,</span> <span class="n">nearest_points</span><span class="p">,</span> <span class="n">snap</span>
<span class="kn">from</span> <span class="nn">geopy.distance</span> <span class="kn">import</span> <span class="n">geodesic</span><span class="p">,</span> <span class="n">distance</span>
<span class="kn">import</span> <span class="nn">openrouteservice</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">folium</span>
<span class="kn">import</span> <span class="nn">branca.colormap</span> <span class="k">as</span> <span class="nn">cm</span>

<span class="kn">from</span> <span class="nn">evpv</span> <span class="kn">import</span> <span class="n">helpers</span> <span class="k">as</span> <span class="n">hlp</span>

<div class="viewcode-block" id="MobilitySim">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim">[docs]</a>
<span class="k">class</span> <span class="nc">MobilitySim</span><span class="p">:</span>
    <span class="c1">#######################################</span>
    <span class="c1">############ Class Methods ############</span>
    <span class="c1">#######################################</span>

<div class="viewcode-block" id="MobilitySim.from_pickle">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.from_pickle">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_pickle</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">pickle_file</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pickle_file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> MobilitySim object loaded from pickle file&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">obj</span></div>


    <span class="c1">#######################################</span>
    <span class="c1">############# Constructor #############</span>
    <span class="c1">####################################### </span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_area</span><span class="p">,</span> <span class="n">population_density</span><span class="p">,</span> <span class="n">destinations</span><span class="p">):</span>
        <span class="c1"># Input data</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">target_area</span> <span class="o">=</span> <span class="n">target_area</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">population_density</span> <span class="o">=</span> <span class="n">population_density</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span> <span class="o">=</span> <span class="n">destinations</span>
            
        <span class="c1"># Transport model setup </span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_simulation_bbox</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_taz_width</span> <span class="o">=</span> <span class="mf">.0</span>

        <span class="c1"># Transport model results</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_zones</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_flows</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Track the state of the object </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s1">&#39;created&#39;</span>  

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> New MobilitySim object created&quot;</span><span class="p">)</span>

    <span class="c1">#######################################</span>
    <span class="c1">####### Main Getters and Setters ######</span>
    <span class="c1">#######################################</span>

    <span class="c1"># Target area</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">target_area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_target_area</span>

    <span class="nd">@target_area</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">target_area</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> The geojson at </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>

        <span class="c1"># Load the GeoJSON file</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">geojson_data</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="c1"># Convert the GEOJSON data to a shapely object</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">geojson_data</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span>
        <span class="n">shapely_shape</span> <span class="o">=</span> <span class="n">shape</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_target_area</span> <span class="o">=</span> <span class="n">shapely_shape</span>

    <span class="c1"># Population density</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">population_density</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_population_density</span>

    <span class="nd">@population_density</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">population_density</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> The population density at </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_population_density</span> <span class="o">=</span> <span class="n">path</span>

    <span class="c1"># Destinations</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">destinations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_destinations</span>

    <span class="nd">@destinations</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">destinations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> The CSV for destinations at </span><span class="si">{</span><span class="n">path</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span><span class="p">)</span>
        
        <span class="n">center_points</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">csv_file</span><span class="p">:</span>
            <span class="n">csv_reader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">DictReader</span><span class="p">(</span><span class="n">csv_file</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">csv_reader</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
                <span class="n">latitude</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;latitude&#39;</span><span class="p">])</span>
                <span class="n">longitude</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;longitude&#39;</span><span class="p">])</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;weight&#39;</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">weight</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ALERT </span><span class="se">\t</span><span class="s2"> Skipping </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> due to non-positive weight: </span><span class="si">{</span><span class="n">weight</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">continue</span>
                    
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">weight</span><span class="p">):</span>
                    <span class="n">center_points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">longitude</span><span class="p">,</span> <span class="n">latitude</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_destinations</span> <span class="o">=</span> <span class="n">center_points</span>             

    <span class="c1"># Target Area Centroid Coordinates</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">centroid_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>    
        <span class="c1"># Get the centroid of the shape</span>
        <span class="n">centroid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_area</span><span class="o">.</span><span class="n">centroid</span>
        
        <span class="c1"># Return the coordinates of the centroid</span>
        <span class="k">return</span> <span class="n">centroid</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">centroid</span><span class="o">.</span><span class="n">x</span>

    <span class="c1">#######################################</span>
    <span class="c1">######### Simulation setup ############</span>
    <span class="c1">#######################################</span>

<div class="viewcode-block" id="MobilitySim.setup_simulation">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.setup_simulation">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_simulation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taz_target_width_km</span><span class="p">,</span> <span class="n">simulation_area_extension_km</span><span class="p">,</span> <span class="n">population_to_ignore_share</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> SIMULATION SETUP&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_simulation_bbox</span><span class="p">(</span><span class="n">simulation_area_extension_km</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_taz_width</span><span class="p">(</span><span class="n">taz_target_width_km</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_taz</span><span class="p">(</span><span class="n">population_to_ignore_share</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;initialized&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Simulation setup done. Make sure to rerun trip generation and distribution if needed.&quot;</span><span class="p">)</span>        
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="se">\t</span><span class="s2"> Simulation area - Width: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">simulation_area_width</span><span class="si">}</span><span class="s2"> km | Height: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">simulation_area_height</span><span class="si">}</span><span class="s2"> km | Pop: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">[</span><span class="s1">&#39;population&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2"> | Destinations: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">[</span><span class="s1">&#39;destinations&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="se">\t</span><span class="s2"> TAZ - Number: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">)</span><span class="si">}</span><span class="s2"> | Width: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">taz_width</span><span class="si">}</span><span class="s2"> km | Height: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">taz_height</span><span class="si">}</span><span class="s2"> km &quot;</span><span class="p">)</span></div>


    <span class="c1"># Simulation bbox</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">simulation_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_simulation_bbox</span>

<div class="viewcode-block" id="MobilitySim.set_simulation_bbox">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.set_simulation_bbox">[docs]</a>
    <span class="k">def</span> <span class="nf">set_simulation_bbox</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">simulation_area_extension_km</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Extending the simulation bbox by </span><span class="si">{</span><span class="n">simulation_area_extension_km</span><span class="si">}</span><span class="s2"> km&quot;</span><span class="p">)</span>

        <span class="c1">#Get the bounding box of the shapefile defininf the target area</span>
        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_area</span><span class="o">.</span><span class="n">bounds</span>

        <span class="c1"># Calculate the new boundaries by extending them</span>
        <span class="k">def</span> <span class="nf">extend_bbox</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">km_extension</span><span class="p">):</span>
            <span class="c1"># Extend minx and maxx by the km_extension in the longitudinal direction</span>
            <span class="n">left_point</span> <span class="o">=</span> <span class="n">geodesic</span><span class="p">(</span><span class="n">kilometers</span><span class="o">=</span><span class="n">km_extension</span><span class="p">)</span><span class="o">.</span><span class="n">destination</span><span class="p">((</span><span class="n">miny</span><span class="p">,</span> <span class="n">minx</span><span class="p">),</span> <span class="mi">270</span><span class="p">)</span>
            <span class="n">right_point</span> <span class="o">=</span> <span class="n">geodesic</span><span class="p">(</span><span class="n">kilometers</span><span class="o">=</span><span class="n">km_extension</span><span class="p">)</span><span class="o">.</span><span class="n">destination</span><span class="p">((</span><span class="n">maxy</span><span class="p">,</span> <span class="n">maxx</span><span class="p">),</span> <span class="mi">90</span><span class="p">)</span>
            
            <span class="c1"># Extend miny and maxy by the km_extension in the latitudinal direction</span>
            <span class="n">bottom_point</span> <span class="o">=</span> <span class="n">geodesic</span><span class="p">(</span><span class="n">kilometers</span><span class="o">=</span><span class="n">km_extension</span><span class="p">)</span><span class="o">.</span><span class="n">destination</span><span class="p">((</span><span class="n">miny</span><span class="p">,</span> <span class="n">minx</span><span class="p">),</span> <span class="mi">180</span><span class="p">)</span>
            <span class="n">top_point</span> <span class="o">=</span> <span class="n">geodesic</span><span class="p">(</span><span class="n">kilometers</span><span class="o">=</span><span class="n">km_extension</span><span class="p">)</span><span class="o">.</span><span class="n">destination</span><span class="p">((</span><span class="n">maxy</span><span class="p">,</span> <span class="n">maxx</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            
            <span class="n">new_minx</span> <span class="o">=</span> <span class="n">left_point</span><span class="o">.</span><span class="n">longitude</span>
            <span class="n">new_maxx</span> <span class="o">=</span> <span class="n">right_point</span><span class="o">.</span><span class="n">longitude</span>
            <span class="n">new_miny</span> <span class="o">=</span> <span class="n">bottom_point</span><span class="o">.</span><span class="n">latitude</span>
            <span class="n">new_maxy</span> <span class="o">=</span> <span class="n">top_point</span><span class="o">.</span><span class="n">latitude</span>
            
            <span class="k">return</span> <span class="n">new_minx</span><span class="p">,</span> <span class="n">new_miny</span><span class="p">,</span> <span class="n">new_maxx</span><span class="p">,</span> <span class="n">new_maxy</span>

        <span class="n">new_minx</span><span class="p">,</span> <span class="n">new_miny</span><span class="p">,</span> <span class="n">new_maxx</span><span class="p">,</span> <span class="n">new_maxy</span> <span class="o">=</span> <span class="n">extend_bbox</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">simulation_area_extension_km</span><span class="p">)</span>

        <span class="c1"># Return the coordinates of the centroid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_simulation_bbox</span> <span class="o">=</span> <span class="n">new_minx</span><span class="p">,</span> <span class="n">new_miny</span><span class="p">,</span> <span class="n">new_maxx</span><span class="p">,</span> <span class="n">new_maxy</span></div>


    <span class="c1"># Simulation Area: Width and Height</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">simulation_area_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_bbox</span>
        <span class="k">return</span> <span class="n">geodesic</span><span class="p">((</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">miny</span><span class="p">))</span><span class="o">.</span><span class="n">kilometers</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">simulation_area_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_bbox</span>
        <span class="k">return</span> <span class="n">geodesic</span><span class="p">((</span><span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">),</span> <span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">))</span><span class="o">.</span><span class="n">kilometers</span>

    <span class="c1"># TAZ: Width, Height, Number of zones</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">taz_width</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_taz_width</span>

<div class="viewcode-block" id="MobilitySim.set_taz_width">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.set_taz_width">[docs]</a>
    <span class="k">def</span> <span class="nf">set_taz_width</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">taz_target_width_km</span><span class="p">):</span>
        <span class="c1"># Compute the number of integer segments close to the target width</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simulation_area_width</span> <span class="o">/</span> <span class="n">taz_target_width_km</span><span class="p">)</span>

        <span class="c1"># Calculate the actual segment length</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_area_width</span> <span class="o">/</span> <span class="n">n</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_taz_width</span> <span class="o">=</span> <span class="n">l</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">taz_height</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_area_height</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_subdivisions</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_subdivisions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">simulation_area_width</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">taz_width</span><span class="p">)</span>

    <span class="c1"># TAZ Initialization</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">traffic_zones</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_zones</span>

<div class="viewcode-block" id="MobilitySim.init_taz">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.init_taz">[docs]</a>
    <span class="k">def</span> <span class="nf">init_taz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">population_to_ignore_share</span> <span class="o">=</span> <span class="mf">.0</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Setting up traffic analysis zones (TAZs) and associated features&quot;</span><span class="p">)</span>

        <span class="c1"># Split the area into n x n zones </span>

        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_bbox</span>

        <span class="n">width_bbox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_area_width</span>
        <span class="n">size_unit_cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taz_width</span>
        <span class="n">num_squares</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_subdivisions</span>
    
        <span class="c1"># Calculate the width and height of each zone</span>
        <span class="n">width</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_squares</span>
        <span class="n">height</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_squares</span>
        
        <span class="n">grid_data</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Loop to create grid and calculate center of each square        </span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_squares</span><span class="p">):</span>     
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_squares</span><span class="p">):</span>
                <span class="c1"># 0. ID </span>
                <span class="n">zone_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span>

                <span class="c1"># 1. Latitude and longitude of the geometric center </span>
                <span class="n">center_lon</span> <span class="o">=</span> <span class="n">miny</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">height</span>
                <span class="n">center_lat</span> <span class="o">=</span> <span class="n">minx</span> <span class="o">+</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">width</span>

                <span class="c1"># 2. Bounding box </span>

                <span class="n">lower_left_x</span> <span class="o">=</span> <span class="n">minx</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="n">width</span>
                <span class="n">lower_left_y</span> <span class="o">=</span> <span class="n">miny</span> <span class="o">+</span> <span class="n">j</span> <span class="o">*</span> <span class="n">height</span>
                <span class="n">upper_right_x</span> <span class="o">=</span> <span class="n">lower_left_x</span> <span class="o">+</span> <span class="n">width</span>
                <span class="n">upper_right_y</span> <span class="o">=</span> <span class="n">lower_left_y</span> <span class="o">+</span> <span class="n">height</span>

                <span class="n">bbox_geom</span> <span class="o">=</span> <span class="n">box</span><span class="p">(</span><span class="n">lower_left_x</span><span class="p">,</span> <span class="n">lower_left_y</span><span class="p">,</span> <span class="n">upper_right_x</span><span class="p">,</span> <span class="n">upper_right_y</span><span class="p">)</span>

                <span class="c1"># 3. Population within the bounding box</span>

                <span class="c1"># GeoDataFrame</span>
                <span class="n">bbox_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">({</span><span class="s1">&#39;geometry&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">bbox_geom</span><span class="p">]},</span> <span class="n">crs</span><span class="o">=</span><span class="s2">&quot;EPSG:4326&quot;</span><span class="p">)</span>

                <span class="c1"># Path to the population raster file</span>
                <span class="n">population_raster_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">population_density</span>

                <span class="c1"># Read the population raster</span>
                <span class="k">with</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">population_raster_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">src</span><span class="p">:</span>
                    <span class="c1"># Clip the raster using the bounding box</span>
                    <span class="n">out_image</span><span class="p">,</span> <span class="n">out_transform</span> <span class="o">=</span> <span class="n">rasterio</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">mask</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="p">[</span><span class="n">bbox_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">crop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">out_meta</span> <span class="o">=</span> <span class="n">src</span><span class="o">.</span><span class="n">meta</span>

                <span class="c1"># Calculate the total population within the bounding box</span>
                <span class="n">total_population</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">out_image</span><span class="p">[</span><span class="n">out_image</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>  <span class="c1"># assuming no data values are &lt;= 0</span>

                <span class="c1"># 4. Number of destinations</span>

                <span class="c1"># Convert the list of center points to shapely Point objects</span>
                <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">Point</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">)</span> <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">destinations</span><span class="p">]</span>

                <span class="c1"># Count how many points are within the bounding box</span>
                <span class="n">points_within_bbox</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">points</span> <span class="k">if</span> <span class="n">point</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">bbox_geom</span><span class="p">)]</span>
                <span class="n">n_destinations</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">points_within_bbox</span><span class="p">)</span>

                <span class="c1"># 5. Check if the TAZ is inside the target area</span>
                
                <span class="n">shapefile_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_area</span>
                <span class="n">center_point</span> <span class="o">=</span> <span class="n">Point</span><span class="p">((</span><span class="n">center_lat</span><span class="p">,</span> <span class="n">center_lon</span><span class="p">))</span>

                <span class="c1"># Check if the point is within the MultiPolygon</span>
                <span class="n">is_within</span> <span class="o">=</span> <span class="n">shapefile_geometry</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">center_point</span><span class="p">)</span>

                <span class="c1"># 5. Append everything</span>

                <span class="n">grid_data</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">zone_id</span><span class="p">,</span> <span class="s1">&#39;geometric_center&#39;</span><span class="p">:</span> <span class="p">(</span><span class="n">center_lat</span><span class="p">,</span> <span class="n">center_lon</span><span class="p">),</span> <span class="s1">&#39;bbox&#39;</span><span class="p">:</span> <span class="n">bbox_geom</span><span class="p">,</span> <span class="s1">&#39;population&#39;</span><span class="p">:</span> <span class="n">total_population</span><span class="p">,</span> <span class="s1">&#39;destinations&#39;</span><span class="p">:</span> <span class="n">n_destinations</span><span class="p">,</span> <span class="s1">&#39;is_within_target_area&#39;</span><span class="p">:</span> <span class="n">is_within</span><span class="p">})</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">grid_data</span><span class="p">)</span>

        <span class="c1"># Delete the sparsely TAZs, such that the sum of the less populated is below a threshold</span>
        <span class="k">if</span> <span class="n">population_to_ignore_share</span>  <span class="o">&gt;</span> <span class="mf">.0</span> <span class="ow">and</span> <span class="n">population_to_ignore_share</span>  <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Deleting sparsely populated TAZs&quot;</span><span class="p">)</span>

            <span class="c1"># Calculate the total population</span>
            <span class="n">total_population</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;population&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="c1"># Calculate the population limit based on the percentage</span>
            <span class="n">population_limit</span> <span class="o">=</span> <span class="n">population_to_ignore_share</span> <span class="o">*</span> <span class="n">total_population</span>

            <span class="c1"># Sort by population in ascending order</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="s1">&#39;population&#39;</span><span class="p">)</span>

            <span class="c1"># Calculate the cumulative sum of populations</span>
            <span class="n">df</span><span class="p">[</span><span class="s1">&#39;cumulative_population&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;population&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>

            <span class="c1"># Identify the rows to remove</span>
            <span class="n">rows_to_remove</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;cumulative_population&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">population_limit</span><span class="p">]</span>

            <span class="c1"># Drop these rows from the original DataFrame</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">rows_to_remove</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

            <span class="c1"># Optionally, remove the cumulative_population column</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;cumulative_population&#39;</span><span class="p">])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_zones</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>


    <span class="c1">#######################################</span>
    <span class="c1">########## Trip Generation ############</span>
    <span class="c1">#######################################</span>

<div class="viewcode-block" id="MobilitySim.trip_generation">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.trip_generation">[docs]</a>
    <span class="k">def</span> <span class="nf">trip_generation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_trips_per_inhabitant</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> TRIP GENERATION&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s2">&quot;initialized&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> Trip generation must be performed right after simulation setup&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n_trips_per_inhabitant</span> <span class="o">&lt;=</span> <span class="mf">.0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> Trips per inhabitant must be greater than 0&quot;</span><span class="p">)</span>

        <span class="c1"># Load the traffic_zones dataframe</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span>

        <span class="c1"># Calculate the number of trips and append them to the df</span>
        <span class="n">df</span><span class="p">[</span><span class="s1">&#39;n_outflows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;population&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">n_trips_per_inhabitant</span><span class="p">)</span> <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_zones</span> <span class="o">=</span> <span class="n">df</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;generation_done&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Trip generation done. Make sure to rerun trip distribution if needed.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Total number of trips: </span><span class="si">{</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;n_outflows&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


    <span class="c1">#######################################</span>
    <span class="c1">######## Trip Distribution ############</span>
    <span class="c1">#######################################</span>

<div class="viewcode-block" id="MobilitySim.trip_distribution">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.trip_distribution">[docs]</a>
    <span class="k">def</span> <span class="nf">trip_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">,</span> <span class="n">ors_key</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">attraction_feature</span> <span class="o">=</span> <span class="s2">&quot;population&quot;</span><span class="p">,</span> <span class="n">cost_feature</span> <span class="o">=</span> <span class="s2">&quot;distance_road&quot;</span><span class="p">,</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="mi">49</span><span class="p">,</span> <span class="n">km_per_capita_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">road_to_euclidian_ratio</span> <span class="o">=</span> <span class="mf">1.63</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> TRIP DISTRIBUTION&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s2">&quot;generation_done&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> Trip distribution must be performed right after trip generation&quot;</span><span class="p">)</span>

        <span class="c1">############ Get TAZ data ############</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span>

        <span class="c1"># Check if trip generation has been performed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;n_outflows&#39;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> Traffic Analysis Zones do not contain the number of trips: trip generation must be performed before trip distribution.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1">############ Get Road Distance ############</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Getting road distance&quot;</span><span class="p">)</span>

        <span class="c1"># Extract coordinates of the centroid</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span> <span class="k">for</span> <span class="n">coord</span> <span class="ow">in</span> <span class="n">df</span><span class="p">[</span><span class="s1">&#39;geometric_center&#39;</span><span class="p">]]</span> 
        <span class="n">num_coordinates</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>

        <span class="c1"># Initialize the full matrices</span>
        <span class="n">durations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_coordinates</span><span class="p">,</span> <span class="n">num_coordinates</span><span class="p">))</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_coordinates</span><span class="p">,</span> <span class="n">num_coordinates</span><span class="p">))</span>

        <span class="c1"># If the user provides an ORS key</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ors_key</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Calculating distance by road using ORS matrix request&quot;</span><span class="p">)</span>

            <span class="c1"># Check if the number of coordinates exceeds the batch size</span>
            <span class="k">if</span> <span class="n">num_coordinates</span> <span class="o">&gt;</span> <span class="n">batch_size</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ALERT </span><span class="se">\t</span><span class="s2"> </span><span class="si">{</span><span class="n">num_coordinates</span><span class="si">}</span><span class="s2"> origins/destinations: this number is greater than the batch size set at </span><span class="si">{</span><span class="n">batch_size</span><span class="si">}</span><span class="s2">. Multiple ORS requests are needed.&quot;</span><span class="p">)</span>

            <span class="c1"># Initialize ORS client</span>
            <span class="n">client</span> <span class="o">=</span> <span class="n">openrouteservice</span><span class="o">.</span><span class="n">Client</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">ors_key</span><span class="p">)</span>  <span class="c1"># Replace with your ORS API key</span>

            <span class="c1"># Split the coordinates into manageable batches</span>
            <span class="n">coordinate_batches</span> <span class="o">=</span> <span class="p">[</span><span class="n">coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">batch_size</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">coordinates</span><span class="p">),</span> <span class="n">batch_size</span><span class="p">)]</span>

            <span class="c1"># Make multiple requests to the ORS API for each batch</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">batch</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">coordinate_batches</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Sending ORS request for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span><span class="si">}</span><span class="s2"> origins/destinations.&quot;</span><span class="p">)</span>

                <span class="n">batch_matrix</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">(</span>
                    <span class="n">locations</span><span class="o">=</span><span class="n">batch</span><span class="p">,</span>
                    <span class="n">profile</span><span class="o">=</span><span class="s1">&#39;driving-car&#39;</span><span class="p">,</span>
                    <span class="n">metrics</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">],</span>
                    <span class="n">resolve_locations</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                
                <span class="c1"># Extract travel times and distances from the response</span>
                <span class="n">batch_durations</span> <span class="o">=</span> <span class="n">batch_matrix</span><span class="p">[</span><span class="s1">&#39;durations&#39;</span><span class="p">]</span>
                <span class="n">batch_distances</span> <span class="o">=</span> <span class="n">batch_matrix</span><span class="p">[</span><span class="s1">&#39;distances&#39;</span><span class="p">]</span>
                
                <span class="c1"># Determine the range of indices for this batch</span>
                <span class="n">batch_start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">batch_size</span>
                <span class="n">batch_end</span> <span class="o">=</span> <span class="n">batch_start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">batch</span><span class="p">)</span>
                
                <span class="c1"># Populate the corresponding section of the full matrices</span>
                <span class="n">durations</span><span class="p">[</span><span class="n">batch_start</span><span class="p">:</span><span class="n">batch_end</span><span class="p">,</span> <span class="n">batch_start</span><span class="p">:</span><span class="n">batch_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">batch_durations</span>
                <span class="n">distances</span><span class="p">[</span><span class="n">batch_start</span><span class="p">:</span><span class="n">batch_end</span><span class="p">,</span> <span class="n">batch_start</span><span class="p">:</span><span class="n">batch_end</span><span class="p">]</span> <span class="o">=</span> <span class="n">batch_distances</span>
                
                <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Introduce a delay between requests to avoid rate limiting</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Distance by road calculated using empirical road-to-euclidian ratio equal to </span><span class="si">{</span><span class="n">road_to_euclidian_ratio</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Define constants for distance and time within two points located in the same zone</span>
        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_bbox</span>

        <span class="c1"># Prepare lists to hold the data</span>
        <span class="n">origin_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">destination_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">flows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">travel_times</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">travel_distances</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">travel_distances_euclidian</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Populate the data based on the matrix response or on the road/euclidian distance ratio</span>
        <span class="n">ors_errors</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">origin_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">destination_id</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]):</span>
                <span class="n">origin_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">origin_id</span><span class="p">)</span>
                <span class="n">destination_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">destination_id</span><span class="p">)</span>

                <span class="n">flows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>  <span class="c1"># Placeholded for the flow for all origin-destination pairs                </span>

                <span class="c1"># Calculate euclidian travel distance and append data</span>
                <span class="n">point1</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">origin_id</span><span class="p">,</span> <span class="s1">&#39;geometric_center&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">point2</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">destination_id</span><span class="p">,</span> <span class="s1">&#39;geometric_center&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">euclidian_distance</span> <span class="o">=</span> <span class="n">geodesic</span><span class="p">(</span><span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">)</span><span class="o">.</span><span class="n">kilometers</span>

                <span class="n">travel_distances_euclidian</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">euclidian_distance</span><span class="p">)</span>

                <span class="c1"># For all zero distances (the case for all combinations if ORS calculation has not been performed)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="ow">or</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mf">.0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">origin_id</span> <span class="o">!=</span> <span class="n">destination_id</span><span class="p">):</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="n">euclidian_distance</span> <span class="o">*</span> <span class="n">road_to_euclidian_ratio</span>

                    <span class="n">travel_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">euclidian_distance</span> <span class="o">*</span> <span class="n">road_to_euclidian_ratio</span><span class="p">)</span>
                    <span class="n">travel_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance</span> <span class="o">/</span> <span class="mi">30</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

                    <span class="c1"># If ors calculation was done, calculate the number of unresolved locations</span>
                    <span class="k">if</span> <span class="n">ors_key</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ors_errors</span> <span class="o">=</span> <span class="n">ors_errors</span> <span class="o">+</span> <span class="mi">1</span>
                        
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">travel_distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># Convert meters to kilometer</span>
                    <span class="n">travel_times</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">durations</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">/</span> <span class="mi">60</span><span class="p">)</span>  <span class="c1"># Convert seconds to minutes</span>

        <span class="k">if</span> <span class="n">ors_errors</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ALERT </span><span class="se">\t</span><span class="s2"> ORS was unable to calculate distance or resolve </span><span class="si">{</span><span class="n">ors_errors</span><span class="si">}</span><span class="s2"> routes. Using road to euclidian distance ratio instead and a travel speed of 30 km/h. This could affect the model reliability!&quot;</span><span class="p">)</span>

        <span class="c1"># Create the resulting DataFrame</span>
        <span class="n">flow_data</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;Origin&#39;</span><span class="p">:</span> <span class="n">origin_ids</span><span class="p">,</span>
            <span class="s1">&#39;Destination&#39;</span><span class="p">:</span> <span class="n">destination_ids</span><span class="p">,</span>
            <span class="s1">&#39;Flow&#39;</span><span class="p">:</span> <span class="n">flows</span><span class="p">,</span>
            <span class="s1">&#39;Travel Time (min)&#39;</span><span class="p">:</span> <span class="n">travel_times</span><span class="p">,</span>
            <span class="s1">&#39;Travel Distance (km)&#39;</span><span class="p">:</span> <span class="n">travel_distances</span><span class="p">,</span>
            <span class="s1">&#39;Centroid Distance (km)&#39;</span><span class="p">:</span> <span class="n">travel_distances_euclidian</span>
        <span class="p">}</span>

        <span class="n">flows_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">flow_data</span><span class="p">)</span>

        <span class="c1">############ Remove rows where &#39;Origin&#39; is equal to &#39;Destination&#39; ############</span>

        <span class="c1"># This is to ensure that spatial interaction model holds </span>

        <span class="n">flows_df</span> <span class="o">=</span> <span class="n">flows_df</span><span class="p">[</span><span class="n">flows_df</span><span class="p">[</span><span class="s1">&#39;Origin&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">flows_df</span><span class="p">[</span><span class="s1">&#39;Destination&#39;</span><span class="p">]]</span>

        <span class="c1">############ Apply spatial interaction model ############</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Applying spatial interaction model&quot;</span><span class="p">)</span>

        <span class="c1"># Iterate over each origin and apply the model</span>
        <span class="n">unit_surface_alert</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># Flag in the case of the auto-calibrated gravity model</span>

        <span class="k">for</span> <span class="n">origin</span> <span class="ow">in</span> <span class="n">flows_df</span><span class="p">[</span><span class="s1">&#39;Origin&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
            <span class="c1"># Filter rows for the current origin</span>
            <span class="n">origin_rows</span> <span class="o">=</span> <span class="n">flows_df</span><span class="p">[</span><span class="n">flows_df</span><span class="p">[</span><span class="s1">&#39;Origin&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">origin</span><span class="p">]</span>
            <span class="n">origin_id</span> <span class="o">=</span> <span class="n">origin_rows</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;Origin&#39;</span><span class="p">]</span>

            <span class="c1"># SIM input: outgoing trips</span>
            <span class="n">n_outflows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">origin_id</span> <span class="p">,</span> <span class="s1">&#39;n_outflows&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># SIM input: attraction</span>
            <span class="k">if</span> <span class="n">attraction_feature</span> <span class="o">==</span> <span class="s1">&#39;population&#39;</span><span class="p">:</span>
                <span class="n">att_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">origin_id</span> <span class="p">,</span> <span class="s1">&#39;population&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dest_att_list</span> <span class="o">=</span> <span class="n">origin_rows</span><span class="p">[</span><span class="s1">&#39;Destination&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;population&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>          
            <span class="k">elif</span> <span class="n">attraction_feature</span> <span class="o">==</span> <span class="s1">&#39;destinations&#39;</span><span class="p">:</span>
                <span class="n">att_origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">origin_id</span> <span class="p">,</span> <span class="s1">&#39;destinations&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dest_att_list</span> <span class="o">=</span> <span class="n">origin_rows</span><span class="p">[</span><span class="s1">&#39;Destination&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">,</span> <span class="s1">&#39;destinations&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> Attraction feature is unknown.&quot;</span><span class="p">)</span>

            <span class="c1"># SIM input: cost</span>
            <span class="k">if</span> <span class="n">cost_feature</span> <span class="o">==</span> <span class="s1">&#39;distance_road&#39;</span><span class="p">:</span>
                <span class="n">cost_list</span> <span class="o">=</span> <span class="n">origin_rows</span><span class="p">[</span><span class="s1">&#39;Travel Distance (km)&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="c1"># Extract the &quot;Travel Distance (km)&quot; column into a list</span>
            <span class="k">elif</span> <span class="n">cost_feature</span> <span class="o">==</span> <span class="s1">&#39;time_road&#39;</span><span class="p">:</span>
                <span class="n">cost_list</span> <span class="o">=</span> <span class="n">origin_rows</span><span class="p">[</span><span class="s1">&#39;Travel Time (min)&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="c1"># Extract the &quot;Travel Time (min)&quot; column into a list</span>
            <span class="k">elif</span> <span class="n">cost_feature</span> <span class="o">==</span> <span class="s1">&#39;distance_centroid&#39;</span><span class="p">:</span>
                <span class="n">cost_list</span> <span class="o">=</span> <span class="n">origin_rows</span><span class="p">[</span><span class="s1">&#39;Centroid Distance (km)&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="c1"># Extract the &quot;Centroid Distance (km)&quot; column into a list</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> Cost feature is unknown.&quot;</span><span class="p">)</span>  

            <span class="c1"># Calculate the flows depending on the model </span>
            <span class="k">if</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;gravity_power_1&#39;</span><span class="p">:</span>
                <span class="n">flows</span> <span class="o">=</span> <span class="n">hlp</span><span class="o">.</span><span class="n">prod_constrained_gravity_power</span><span class="p">(</span>
                    <span class="n">origin_n_trips</span> <span class="o">=</span> <span class="n">n_outflows</span><span class="p">,</span>
                    <span class="n">dest_attractivity_list</span> <span class="o">=</span> <span class="n">dest_att_list</span><span class="p">,</span>                
                    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">cost_list</span><span class="p">,</span> 
                    <span class="n">gamma</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;gravity_exp_1&#39;</span><span class="p">:</span>
                <span class="n">flows</span> <span class="o">=</span> <span class="n">hlp</span><span class="o">.</span><span class="n">prod_constrained_gravity_exp</span><span class="p">(</span>
                    <span class="n">origin_n_trips</span> <span class="o">=</span> <span class="n">n_outflows</span><span class="p">,</span>
                    <span class="n">dest_attractivity_list</span> <span class="o">=</span> <span class="n">dest_att_list</span><span class="p">,</span>                
                    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">cost_list</span><span class="p">,</span> 
                    <span class="n">beta</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;gravity_exp_01&#39;</span><span class="p">:</span>
                <span class="n">flows</span> <span class="o">=</span> <span class="n">hlp</span><span class="o">.</span><span class="n">prod_constrained_gravity_exp</span><span class="p">(</span>
                    <span class="n">origin_n_trips</span> <span class="o">=</span> <span class="n">n_outflows</span><span class="p">,</span>
                    <span class="n">dest_attractivity_list</span> <span class="o">=</span> <span class="n">dest_att_list</span><span class="p">,</span>                
                    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">cost_list</span><span class="p">,</span> 
                    <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;gravity_exp_02&#39;</span><span class="p">:</span>
                <span class="n">flows</span> <span class="o">=</span> <span class="n">hlp</span><span class="o">.</span><span class="n">prod_constrained_gravity_exp</span><span class="p">(</span>
                    <span class="n">origin_n_trips</span> <span class="o">=</span> <span class="n">n_outflows</span><span class="p">,</span>
                    <span class="n">dest_attractivity_list</span> <span class="o">=</span> <span class="n">dest_att_list</span><span class="p">,</span>                
                    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">cost_list</span><span class="p">,</span> 
                    <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;gravity_exp_016&#39;</span><span class="p">:</span>
                <span class="n">flows</span> <span class="o">=</span> <span class="n">hlp</span><span class="o">.</span><span class="n">prod_constrained_gravity_exp</span><span class="p">(</span>
                    <span class="n">origin_n_trips</span> <span class="o">=</span> <span class="n">n_outflows</span><span class="p">,</span>
                    <span class="n">dest_attractivity_list</span> <span class="o">=</span> <span class="n">dest_att_list</span><span class="p">,</span>                
                    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">cost_list</span><span class="p">,</span> 
                    <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.16</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;gravity_exp_scaled&#39;</span><span class="p">:</span>
                <span class="c1"># Gravity model auto-calibrated </span>
                <span class="c1"># https://doi.org/10.1371/journal.pone.0045985</span>
                <span class="c1"># https://doi.org/10.1016/j.jtrangeo.2015.12.008</span>
                <span class="n">unit_surface_km2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">taz_width</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">taz_height</span>
                <span class="k">if</span> <span class="n">unit_surface_km2</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">unit_surface_alert</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ALERT </span><span class="se">\t</span><span class="s2"> The average unit surface area is less than 5 km2, which may cause the scaling law of the gravity model to be invalid.&quot;</span><span class="p">)</span>
                    <span class="n">unit_surface_alert</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">flows</span> <span class="o">=</span> <span class="n">hlp</span><span class="o">.</span><span class="n">prod_constrained_gravity_exp</span><span class="p">(</span>
                    <span class="n">origin_n_trips</span> <span class="o">=</span> <span class="n">n_outflows</span><span class="p">,</span>
                    <span class="n">dest_attractivity_list</span> <span class="o">=</span> <span class="n">dest_att_list</span><span class="p">,</span>                
                    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">cost_list</span><span class="p">,</span> 
                    <span class="n">beta</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">unit_surface_km2</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.18</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;radiation&#39;</span><span class="p">:</span>
                <span class="n">flows</span> <span class="o">=</span> <span class="n">hlp</span><span class="o">.</span><span class="n">prod_constrained_radiation</span><span class="p">(</span>
                    <span class="n">origin_n_trips</span> <span class="o">=</span> <span class="n">n_outflows</span><span class="p">,</span>
                    <span class="n">origin_attractivity</span> <span class="o">=</span> <span class="n">att_origin</span><span class="p">,</span>
                    <span class="n">dest_attractivity_list</span> <span class="o">=</span> <span class="n">dest_att_list</span><span class="p">,</span>                
                    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">cost_list</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">model</span> <span class="o">==</span> <span class="s1">&#39;radius_6km&#39;</span><span class="p">:</span>
                <span class="n">flows</span> <span class="o">=</span> <span class="n">hlp</span><span class="o">.</span><span class="n">prod_constrained_radius</span><span class="p">(</span>
                    <span class="n">origin_n_trips</span> <span class="o">=</span> <span class="n">n_outflows</span><span class="p">,</span>
                    <span class="n">dest_attractivity_list</span> <span class="o">=</span> <span class="n">dest_att_list</span><span class="p">,</span>                
                    <span class="n">cost_list</span> <span class="o">=</span> <span class="n">cost_list</span><span class="p">,</span>
                    <span class="n">radius</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> Spatial interaction model &#39;</span><span class="si">{</span><span class="n">model</span><span class="si">}</span><span class="s2">&#39; is unknown.&quot;</span><span class="p">)</span>

            <span class="c1"># Update the flows column where row_id equals 1</span>
            <span class="n">flows_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">flows_df</span><span class="p">[</span><span class="s1">&#39;Origin&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">origin_id</span><span class="p">,</span> <span class="s1">&#39;Flow&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">flows</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">flows_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">flows_df</span><span class="p">[</span><span class="s1">&#39;Origin&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">origin_id</span><span class="p">])]</span>

        <span class="c1">############ Append flow data ############</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_flows</span> <span class="o">=</span> <span class="n">flows_df</span>

        <span class="c1">############ Append Aggregated data to TAZ ############</span>

        <span class="n">n_outflows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_inflows</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="n">pkm_outflows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pkm_inflows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">km_per_capita_outflows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">km_per_capita_inflows</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Iterate over the TAZ and append data</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>

            <span class="c1"># Append values related to the origin (outflows)            </span>
            <span class="n">out_df</span> <span class="o">=</span> <span class="n">flows_df</span><span class="p">[</span><span class="n">flows_df</span><span class="p">[</span><span class="s1">&#39;Origin&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">out_df</span><span class="p">[</span><span class="s1">&#39;Distance_Flow_Product&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">out_df</span><span class="p">[</span><span class="s1">&#39;Travel Distance (km)&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">km_per_capita_offset</span><span class="p">)</span> <span class="o">*</span> <span class="n">out_df</span><span class="p">[</span><span class="s1">&#39;Flow&#39;</span><span class="p">]</span>

            <span class="n">outflow_sum</span> <span class="o">=</span> <span class="n">out_df</span><span class="p">[</span><span class="s1">&#39;Flow&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">distance_flow_product_sum_out</span> <span class="o">=</span> <span class="n">out_df</span><span class="p">[</span><span class="s1">&#39;Distance_Flow_Product&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">n_outflows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">outflow_sum</span><span class="p">)</span>
            <span class="n">pkm_outflows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance_flow_product_sum_out</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">outflow_sum</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">km_per_capita_outflows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance_flow_product_sum_out</span> <span class="o">/</span> <span class="n">outflow_sum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">km_per_capita_outflows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Append values related to the destination (inflows)            </span>
            <span class="n">in_df</span> <span class="o">=</span> <span class="n">flows_df</span><span class="p">[</span><span class="n">flows_df</span><span class="p">[</span><span class="s1">&#39;Destination&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">in_df</span><span class="p">[</span><span class="s1">&#39;Distance_Flow_Product&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">in_df</span><span class="p">[</span><span class="s1">&#39;Travel Distance (km)&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">km_per_capita_offset</span><span class="p">)</span> <span class="o">*</span> <span class="n">in_df</span><span class="p">[</span><span class="s1">&#39;Flow&#39;</span><span class="p">]</span>

            <span class="n">inflow_sum</span> <span class="o">=</span> <span class="n">in_df</span><span class="p">[</span><span class="s1">&#39;Flow&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="n">distance_flow_product_sum_in</span> <span class="o">=</span> <span class="n">in_df</span><span class="p">[</span><span class="s1">&#39;Distance_Flow_Product&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">n_inflows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inflow_sum</span><span class="p">)</span>
            <span class="n">pkm_inflows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance_flow_product_sum_in</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">inflow_sum</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">km_per_capita_inflows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distance_flow_product_sum_in</span> <span class="o">/</span> <span class="n">inflow_sum</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">km_per_capita_inflows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Add a new column with values from the list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_zones</span><span class="p">[</span><span class="s1">&#39;n_outflows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_outflows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_zones</span><span class="p">[</span><span class="s1">&#39;n_inflows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_inflows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_zones</span><span class="p">[</span><span class="s1">&#39;pkm_outflows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pkm_outflows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_zones</span><span class="p">[</span><span class="s1">&#39;pkm_inflows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pkm_inflows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_zones</span><span class="p">[</span><span class="s1">&#39;km_per_capita_outflows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">km_per_capita_outflows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_traffic_zones</span><span class="p">[</span><span class="s1">&#39;km_per_capita_inflows&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">km_per_capita_inflows</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">=</span> <span class="s2">&quot;distribution_done&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Trip distribution done.&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Passenger-km (road-based): </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pkm</span><span class="si">}</span><span class="s2"> km | Av. distance travelled (road-based ): </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">km_per_capita</span><span class="si">}</span><span class="s2"> km&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2"> Passenger-km (centroid-based): </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pkm_centroid</span><span class="si">}</span><span class="s2"> km | Av. distance travelled (centroid-based): </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">km_per_capita_centroid</span><span class="si">}</span><span class="s2"> km&quot;</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">flows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_flows</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pkm</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">[</span><span class="s1">&#39;pkm_outflows&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pkm_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="s1">&#39;Centroid Distance (km)&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="s1">&#39;Flow&#39;</span><span class="p">])</span>  

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">pkm_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">flows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="s1">&#39;Flow&#39;</span><span class="p">]</span>
        <span class="n">flows_squared</span> <span class="o">=</span> <span class="n">flows</span> <span class="o">**</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taz_width</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">taz_height</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">flows_squared</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span> <span class="c1"># Assuming the error on the distance of each trip is 2 times the diagonal of TAZ (Error propagation)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">km_per_capita_error</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">km_per_capita</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pkm_error</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">pkm</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">km_per_capita</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pkm</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">[</span><span class="s1">&#39;n_outflows&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">km_per_capita_centroid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="s1">&#39;Centroid Distance (km)&#39;</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="s1">&#39;Flow&#39;</span><span class="p">])</span>

    <span class="c1">#######################################</span>
    <span class="c1">############## Routing ################</span>
    <span class="c1">#######################################</span>

<div class="viewcode-block" id="MobilitySim.allocate_routes">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.allocate_routes">[docs]</a>
    <span class="k">def</span> <span class="nf">allocate_routes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ors_key</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Allocation of ORS routes to origin-destination pairs (routing)&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">state</span> <span class="o">!=</span> <span class="s2">&quot;distribution_done&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> Routing cannot be performed before trip distribution&quot;</span><span class="p">)</span>

        <span class="n">flows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span>
        <span class="n">taz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span>

        <span class="c1"># Add a new column for the route geometry</span>
        <span class="n">flows</span><span class="p">[</span><span class="s1">&#39;Geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Initialize ORS client</span>
        <span class="n">client</span> <span class="o">=</span> <span class="n">openrouteservice</span><span class="o">.</span><span class="n">Client</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">ors_key</span><span class="p">)</span>  <span class="c1"># Replace with your ORS API key</span>

        <span class="c1"># Create a dictionary to store previously calculated routes (avoids recalculating when origin and destination are swapped)</span>
        <span class="n">route_cache</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">flows</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Allocation: </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> out of </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">flows</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">origin_id</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Origin&#39;</span><span class="p">]</span>
            <span class="n">destination_id</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Destination&#39;</span><span class="p">]</span>
            <span class="n">flow</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Flow&#39;</span><span class="p">]</span>
            
            <span class="c1"># Create a unique key for each origin-destination pair</span>
            <span class="n">route_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">origin_id</span><span class="p">,</span> <span class="n">destination_id</span><span class="p">]))</span>
            
            <span class="k">if</span> <span class="n">route_key</span> <span class="ow">in</span> <span class="n">route_cache</span><span class="p">:</span>
                <span class="c1"># If the route has been calculated before, use the cached geometry</span>
                <span class="n">geometry</span> <span class="o">=</span> <span class="n">route_cache</span><span class="p">[</span><span class="n">route_key</span><span class="p">]</span>
                <span class="c1"># Check if we need to reverse the LineString</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">origin_id</span><span class="p">,</span> <span class="n">destination_id</span><span class="p">)</span> <span class="o">!=</span> <span class="n">route_key</span><span class="p">:</span>
                    <span class="n">geometry</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">coords</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Get the coordinates from taz</span>
                <span class="n">origin_coords</span> <span class="o">=</span> <span class="n">taz</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">taz</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">origin_id</span><span class="p">,</span> <span class="s1">&#39;geometric_center&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">destination_coords</span> <span class="o">=</span> <span class="n">taz</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">taz</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">destination_id</span><span class="p">,</span> <span class="s1">&#39;geometric_center&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                
                <span class="n">origin_lon</span><span class="p">,</span> <span class="n">origin_lat</span> <span class="o">=</span> <span class="n">origin_coords</span>
                <span class="n">destination_lon</span><span class="p">,</span> <span class="n">destination_lat</span> <span class="o">=</span> <span class="n">destination_coords</span> 
                
                <span class="c1"># Get the route from ORS</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">route</span> <span class="o">=</span> <span class="n">client</span><span class="o">.</span><span class="n">directions</span><span class="p">(</span>
                        <span class="n">coordinates</span><span class="o">=</span><span class="p">[</span><span class="n">origin_coords</span><span class="p">,</span> <span class="n">destination_coords</span><span class="p">],</span>
                        <span class="n">profile</span><span class="o">=</span><span class="s1">&#39;driving-car&#39;</span><span class="p">,</span>
                        <span class="nb">format</span><span class="o">=</span><span class="s1">&#39;geojson&#39;</span>
                    <span class="p">)</span>
                    <span class="n">geometry</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">route</span><span class="p">[</span><span class="s1">&#39;features&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;coordinates&#39;</span><span class="p">])</span>
                    <span class="c1"># Cache the route</span>
                    <span class="n">route_cache</span><span class="p">[</span><span class="n">route_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometry</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR </span><span class="se">\t</span><span class="s2"> An error occurred in route calculation - Geometry is set to None&quot;</span><span class="p">)</span>
                    <span class="n">geometry</span> <span class="o">=</span> <span class="kc">None</span>
            
            <span class="n">flows</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="s1">&#39;Geometry&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">geometry</span>
            
            <span class="c1"># Adding a sleep time to avoid hitting the rate limit</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">1.5</span><span class="p">)</span></div>


    <span class="c1">#######################################</span>
    <span class="c1">############ Save to pickle ###########</span>
    <span class="c1">#######################################</span>

<div class="viewcode-block" id="MobilitySim.to_pickle">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.to_pickle">[docs]</a>
    <span class="k">def</span> <span class="nf">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickle_filename</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Saving MobilitySim object to pickle file&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">pickle_filename</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">)</span></div>


    <span class="c1">#######################################</span>
    <span class="c1">### Post-processing &amp; visualisation ###</span>
    <span class="c1">#######################################</span>

<div class="viewcode-block" id="MobilitySim.km_per_capita_histogram">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.km_per_capita_histogram">[docs]</a>
    <span class="k">def</span> <span class="nf">km_per_capita_histogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bin_width_km</span><span class="p">):</span>
        <span class="n">centroid_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="s1">&#39;Centroid Distance (km)&#39;</span><span class="p">]</span>
        <span class="n">travel_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="s1">&#39;Travel Distance (km)&#39;</span><span class="p">]</span>
        <span class="n">weights</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span><span class="p">[</span><span class="s1">&#39;Flow&#39;</span><span class="p">]</span>

        <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">travel_distance</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">bin_width_km</span><span class="p">)</span>  <span class="c1"># Bins of width 10, from 0 to 10</span>

        <span class="c1"># Calculate the histogram</span>
        <span class="n">centroid_distance_counts</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">centroid_distance</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="n">travel_distance_counts</span><span class="p">,</span> <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">travel_distance</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>

        <span class="c1"># Calculate the bin centers (optional)</span>
        <span class="n">bin_centers</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># Create a DataFrame to store the bin centers and counts</span>
        <span class="n">hist_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span>
            <span class="s1">&#39;Distance (km)&#39;</span><span class="p">:</span> <span class="n">bin_centers</span><span class="p">,</span>
            <span class="s1">&#39;Centroid &#39;</span><span class="p">:</span> <span class="n">centroid_distance_counts</span><span class="p">,</span>
            <span class="s1">&#39;Travel (road)&#39;</span><span class="p">:</span> <span class="n">travel_distance_counts</span>
        <span class="p">})</span>

        <span class="k">return</span> <span class="n">hist_df</span></div>


<div class="viewcode-block" id="MobilitySim.setup_to_map">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.setup_to_map">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_to_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Generating folium map with simulation setup properties&quot;</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span>

        <span class="c1"># 1. Create an empty map</span>
        <span class="n">m1</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_coords</span><span class="p">,</span> <span class="n">zoom_start</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">tiles</span><span class="o">=</span><span class="s1">&#39;CartoDB Positron&#39;</span><span class="p">,</span> <span class="n">control_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># 2. Add Administrative Boundaries</span>
        <span class="k">def</span> <span class="nf">style_function</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span>
                <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                <span class="s1">&#39;fillColor&#39;</span><span class="p">:</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span>
            <span class="p">}</span>
        
        <span class="n">folium</span><span class="o">.</span><span class="n">GeoJson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_area</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Administrative boundary&#39;</span><span class="p">,</span> <span class="n">style_function</span><span class="o">=</span><span class="n">style_function</span><span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>

        <span class="c1"># 3. Add Simulation bbox</span>
        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">simulation_bbox</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span><span class="n">bounds</span><span class="o">=</span><span class="p">[[</span><span class="n">miny</span><span class="p">,</span> <span class="n">minx</span><span class="p">],</span> <span class="p">[</span><span class="n">maxy</span><span class="p">,</span> <span class="n">maxx</span><span class="p">]],</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_opacity</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>

        <span class="c1"># 5. Add rectangles (using apply)</span>
        <span class="k">def</span> <span class="nf">add_rectangle</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">colormap</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">map_obj</span><span class="p">):</span>
            <span class="n">bbox_polygon</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;bbox&#39;</span><span class="p">]</span>
            <span class="n">bbox_coords</span> <span class="o">=</span> <span class="n">bbox_polygon</span><span class="o">.</span><span class="n">bounds</span>
            <span class="n">folium</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="n">bbox_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bbox_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">bbox_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">bbox_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span>
                <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_color</span><span class="o">=</span><span class="n">colormap</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">col</span><span class="p">]),</span> <span class="n">fill_opacity</span><span class="o">=</span><span class="mf">0.7</span>
            <span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">map_obj</span><span class="p">)</span>

        <span class="c1"># Normalize data for destinations and population</span>
        <span class="n">linear1</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">LinearColormap</span><span class="p">([</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">],</span> <span class="n">vmin</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;destinations&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;destinations&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
        <span class="n">linear2</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">LinearColormap</span><span class="p">([</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">],</span> <span class="n">vmin</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;population&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;population&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

        <span class="c1"># Create FeatureGroups for destinations and population</span>
        <span class="n">destinations_group</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Number of Destinations&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">population_group</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Number of People&#39;</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Add destinations rectangles to the group</span>
        <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">add_rectangle</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">linear1</span><span class="p">,</span> <span class="s1">&#39;destinations&#39;</span><span class="p">,</span> <span class="n">destinations_group</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Add population rectangles to the group</span>
        <span class="n">df</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">add_rectangle</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">linear2</span><span class="p">,</span> <span class="s1">&#39;population&#39;</span><span class="p">,</span> <span class="n">population_group</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Add the FeatureGroups to the map</span>
        <span class="n">destinations_group</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
        <span class="n">population_group</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>

        <span class="c1"># Add color scales</span>
        <span class="n">linear1</span><span class="o">.</span><span class="n">caption</span> <span class="o">=</span> <span class="s1">&#39;Number of destinations&#39;</span>
        <span class="n">linear1</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
        
        <span class="n">linear2</span><span class="o">.</span><span class="n">caption</span> <span class="o">=</span> <span class="s1">&#39;Number of people&#39;</span>
        <span class="n">linear2</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>

        <span class="c1"># 6. Add Layer Control</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">LayerControl</span><span class="p">()</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">m1</span></div>


<div class="viewcode-block" id="MobilitySim.trip_generation_to_map">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.trip_generation_to_map">[docs]</a>
    <span class="k">def</span> <span class="nf">trip_generation_to_map</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Generating folium map from trip generation results&quot;</span><span class="p">)</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span>

        <span class="c1"># 1. Create an empty map</span>
        <span class="n">m2</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_coords</span><span class="p">,</span> <span class="n">zoom_start</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">tiles</span><span class="o">=</span><span class="s1">&#39;CartoDB Positron&#39;</span><span class="p">,</span> <span class="n">control_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Create the map</span>

        <span class="c1"># 2. Add Administrative Boundaries</span>
        <span class="k">def</span> <span class="nf">style_function</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span>
                <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                <span class="s1">&#39;fillColor&#39;</span><span class="p">:</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span>
            <span class="p">}</span>
        
        <span class="n">folium</span><span class="o">.</span><span class="n">GeoJson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_area</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Administrative boundary&#39;</span><span class="p">,</span> <span class="n">style_function</span><span class="o">=</span><span class="n">style_function</span><span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>

        <span class="c1"># 2. Add TAZ boundaries</span>

        <span class="c1"># Function to add rectangles to the map</span>
        <span class="k">def</span> <span class="nf">add_rectangle</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="c1"># Parse the WKT string to create a Polygon object</span>
            <span class="n">bbox_polygon</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;bbox&#39;</span><span class="p">]</span>
            <span class="n">bbox_coords</span> <span class="o">=</span> <span class="n">bbox_polygon</span><span class="o">.</span><span class="n">bounds</span>
            
            <span class="c1"># Add rectangle to map</span>
            <span class="n">folium</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="n">bbox_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bbox_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">bbox_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">bbox_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span>
                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span>
                <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">fill_color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span>
                <span class="n">fill_opacity</span><span class="o">=</span><span class="mf">0.0</span>
            <span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>

        <span class="c1"># Apply the function to each row in the DataFrame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">add_rectangle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># 3. Add number of outflows</span>

        <span class="c1"># Normalize data for color scaling</span>
        <span class="n">linear</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">LinearColormap</span><span class="p">([</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">],</span> <span class="n">vmin</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;n_outflows&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;n_outflows&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

        <span class="c1"># Create a feature group for all polygons</span>
        <span class="n">feature_group</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s1">&#39;Number of trips&#39;</span><span class="p">)</span>

        <span class="c1"># Add polygons to the feature group</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">bbox_polygon</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;bbox&#39;</span><span class="p">]</span>
            <span class="n">bbox_coords</span> <span class="o">=</span> <span class="n">bbox_polygon</span><span class="o">.</span><span class="n">bounds</span>

            <span class="c1"># Create a rectangle for each row</span>
            <span class="n">rectangle</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="n">bbox_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bbox_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">bbox_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">bbox_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span>
                <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">fill_color</span><span class="o">=</span><span class="n">linear</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;n_outflows&#39;</span><span class="p">]),</span>
                <span class="n">fill_opacity</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                <span class="n">popup</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;ID: </span><span class="si">{</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> - Trips: </span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;n_outflows&#39;</span><span class="p">])</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

            <span class="c1"># Add the rectangle to the feature group</span>
            <span class="n">rectangle</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">feature_group</span><span class="p">)</span>

        <span class="c1"># Add the feature group to the map</span>
        <span class="n">feature_group</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>

        <span class="c1"># Add the color scale legend to the map</span>
        <span class="n">linear</span><span class="o">.</span><span class="n">caption</span> <span class="o">=</span> <span class="s1">&#39;Number of Trips (n_outflows)&#39;</span>
        <span class="n">linear</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>

        <span class="c1"># Add Layer Control and Save </span>

        <span class="n">folium</span><span class="o">.</span><span class="n">LayerControl</span><span class="p">()</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">m2</span></div>


<div class="viewcode-block" id="MobilitySim.trip_distribution_to_map">
<a class="viewcode-back" href="../../evpv.html#evpv.mobilitysim.MobilitySim.trip_distribution_to_map">[docs]</a>
    <span class="k">def</span> <span class="nf">trip_distribution_to_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trip_id</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;INFO </span><span class="se">\t</span><span class="s2"> Generating folium map using trip distribution for trip id </span><span class="si">{</span><span class="n">trip_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>        

        <span class="n">m3</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">Map</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">centroid_coords</span><span class="p">,</span> <span class="n">zoom_start</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span> <span class="n">tiles</span><span class="o">=</span><span class="s1">&#39;CartoDB Positron&#39;</span><span class="p">,</span> <span class="n">control_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="c1"># Create the map</span>

        <span class="c1"># Add administrative boundaries</span>

        <span class="c1"># Define style function to only show lines</span>
        <span class="k">def</span> <span class="nf">style_function</span><span class="p">(</span><span class="n">feature</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="s1">&#39;blue&#39;</span><span class="p">,</span>  <span class="c1"># Set line color</span>
                <span class="s1">&#39;weight&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>      <span class="c1"># Set line weight</span>
                <span class="s1">&#39;fillColor&#39;</span><span class="p">:</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span>  <span class="c1"># Set fill color to &#39;none&#39;</span>
            <span class="p">}</span>

        <span class="n">folium</span><span class="o">.</span><span class="n">GeoJson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">target_area</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;Administrative boundary&#39;</span><span class="p">,</span> <span class="n">style_function</span><span class="o">=</span><span class="n">style_function</span><span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m3</span><span class="p">)</span>

        <span class="c1"># Add TAZ boundaries</span>

        <span class="c1"># Function to add rectangles to the map</span>
        <span class="k">def</span> <span class="nf">add_rectangle</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
            <span class="c1"># Parse the WKT string to create a Polygon object</span>
            <span class="n">bbox_polygon</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;bbox&#39;</span><span class="p">]</span>
            <span class="n">bbox_coords</span> <span class="o">=</span> <span class="n">bbox_polygon</span><span class="o">.</span><span class="n">bounds</span>
            
            <span class="c1"># Add rectangle to map</span>
            <span class="n">folium</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="n">bbox_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bbox_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">bbox_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">bbox_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span>
                <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span>
                <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">fill_color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">,</span>
                <span class="n">fill_opacity</span><span class="o">=</span><span class="mf">0.0</span>
            <span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m3</span><span class="p">)</span>

        <span class="c1"># Apply the function to each row in the DataFrame</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">add_rectangle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1">#Add flow</span>

        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flows</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s1">&#39;Origin&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">trip_id</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No TAZ&quot;</span><span class="p">)</span>

        <span class="n">feature_group</span> <span class="o">=</span> <span class="n">folium</span><span class="o">.</span><span class="n">FeatureGroup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Number of trips from </span><span class="si">{</span><span class="n">trip_id</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    
        <span class="c1"># Add flows to the feature group</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">group</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
            <span class="n">linear</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">LinearColormap</span><span class="p">([</span><span class="s2">&quot;white&quot;</span><span class="p">,</span> <span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="s2">&quot;red&quot;</span><span class="p">],</span> <span class="n">vmin</span><span class="o">=</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;Flow&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">group</span><span class="p">[</span><span class="s1">&#39;Flow&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

            <span class="n">bbox_polygon</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">traffic_zones</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;Destination&#39;</span><span class="p">]][</span><span class="s1">&#39;bbox&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1">#print(bbox_polygon[1])</span>
            <span class="n">bbox_coords</span> <span class="o">=</span> <span class="n">bbox_polygon</span><span class="o">.</span><span class="n">bounds</span>

            <span class="n">folium</span><span class="o">.</span><span class="n">Rectangle</span><span class="p">(</span>
                <span class="n">bounds</span><span class="o">=</span><span class="p">[(</span><span class="n">bbox_coords</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">bbox_coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">bbox_coords</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">bbox_coords</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span>
                <span class="n">color</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">fill</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">fill_color</span><span class="o">=</span><span class="n">linear</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">Flow</span><span class="p">),</span>
                <span class="n">fill_opacity</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
                <span class="n">tooltip</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Commuters: </span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">Flow</span><span class="si">}</span><span class="s1"> - Car trips: </span><span class="si">{</span><span class="n">row</span><span class="o">.</span><span class="n">Flow</span><span class="si">}</span><span class="s1"> &#39;</span>
            <span class="p">)</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">feature_group</span><span class="p">)</span>

        <span class="n">feature_group</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m3</span><span class="p">)</span>
        <span class="n">folium</span><span class="o">.</span><span class="n">LayerControl</span><span class="p">()</span><span class="o">.</span><span class="n">add_to</span><span class="p">(</span><span class="n">m3</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">m3</span></div>
</div>

        
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">EV-PV</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../evpv.html">evpv package</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Jeremy Dumoulin.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>